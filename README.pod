=pod

=encoding UTF-8

=head1 NAME

Auto::Mata - State machine grease

=head1 VERSION

version 0.01

=head1 SYNOPSIS

  use strict;
  use warnings;
  use Auto::Mata;
  use Types::Standard -types;

  my $NoData   = Undef,
  my $HasFirst = Tuple[Str];
  my $HasLast  = Tuple[Str, Str];
  my $Complete = Tuple[Str, Str, Int];

  sub get_input {
    my $query = shift;
    print "\n$query ";
    my $input = <STDIN>;
    chomp $input;
    return $input;
  }

  my $fsm = machine {
    ready 'READY';
    terminal 'TERM';

    transition 'READY', to 'FIRST',
      on $NoData,
      with { return [get_input("What is your first name? ")] };

    transition 'FIRST', to 'LAST',
      on $HasFirst,
      with { return [@$_, get_input("What is your last name? ")] };

    transition 'LAST', to 'AGE',
      on $HasLast,
      with { return [@$_, get_input("What is your age? ")] };

    transition 'AGE', to 'TERM',
      on $Complete;
  };

  my $prog = $fsm->(my $data);

  while ($prog->() ne 'TERM') {
    ;
  }

  printf "Hello %s %s, aged %d years!\n", @$data;

=head1 DESCRIPTION

Finite state machines (or automata) are a way of modeling the workflow of a
program as a series of dependent, programmable steps. They are very useful when
designing software that is guaranteed to behave in a predictable way.

In fact, most (all?) programs boil down to a FSM, with each conditional branch
defining a new state, although the author of the program may be unaware of this
and the state may be inspected in an ad hoc manner throughout.

Designing a program as a state machine from the outset is a useful technique to
consistently create reliable, well-behaved software. It forces the author to
think through each step in the program workflow, examining and modeling the data
at each stage during execution of the software.

=head1 EXPORTED SUBROUTINES

C<Auto::Mata> is an C<Exporter>. All subroutines are exported by default.

=head2 machine

Creates a lexical context in which a state machine is defined. Returns a
function that creates new instances of the defined automata. The automata
instance itself is a function that performs a single transition per call,
returning the current state's label in scalar context, the label and state data
(the reference passed to the builder) in list context, and C<undef> after the
terminal state has been reached.

The reference value passed to the builder function holds the machine's
B<mutable> running state and is matched against L<Type::Tiny> type constraints
(see L</transition> and L</on>) to determine the next transition state.

  # Define the state machine
  my $builder = machine {
    ...
  };

  # Create an instance of the machine that operates on $state.
  my $program = $builder->(my $state = [...]);

  # Run the program
  while (my ($token, $data) = $program->()) {
    print "Current state is $token\n"; # $token == label of current state (e.g. READY)
    print "State data: @$data\n";      # $data == $state passed to builder
  }

=head2 ready

Sets the name given to the "ready" state. This is the initial state held by the
state machine.

=head2 terminal

Sets the name given to the "terminal" state. This is the final state held by
the state machine. Once in this state, the machine will cease to perform any
more work.

=head2 transition

These functions define transitions. During a transition, the program will step
from one state to another. Each transition requires a type constraint that is
used to match the current state of the program and may optionally include a
code block that will transform the state reference appropriately for the next
transition.

It is an error to have two identical transitions, even with different
constraints. This is intentional. A transition that matches two different
states is, in fact, two distinct transitions, and the program should be modeled
as such in order to prevent errors due to unexpected or improperly checked
data.  In general, it is a good idea to be as specific as possible with the
type constraints used to define the initial transition state.

The first transition is always from the "ready" state. The final transition is
always to the "terminal" state. There may be no transitions from the "terminal"
state.

The following functions are used in concert with L</transition>.

=over

=item to

A name identifying the state held I<after> the transition.

=item on

A L<Type::Tiny> constraint that matches the state immediately I<before> the
transition.

=item with

A code block whose return type is the mutable state used to determine the
next transition to pefform. Within the code block C<$_> is a reference to
the program state.

=back

=head1 AUTHOR

Jeff Ober <jeffober@gmail.com>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2017 by Jeff Ober.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
